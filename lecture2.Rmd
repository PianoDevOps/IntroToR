---
title: 'Lecture 2: Atomic Data Types/Homogeneous vectors'
author: "Wim R.M. Cardoen"
output:
  pdf_document:
    highlight: tango
    df_print: tibble
    toc: true
    toc_depth: 5
    number_sections: True
    extra_dependencies:
    - amsfonts
    - amsmath
    - xcolor
    - hyperref
urlcolor: violet
---

\newpage

R can be summarized in three principles (John M. Chambers, 2016)

* $\texttt{Everything that exists in R is an \textbf{object}.}$
* $\texttt{Everything that happens in R is a \textbf{function} call.}$
* $\texttt{\textbf{Interfaces} to other languages are a part of R.}$

\newpage

# R Objects 

* An object in R is (internally) represented as a pair: (**symbol**, **value**).
* A **symbol** is assigned a **value** by the use of an arrow pointing to the left ($\textcolor{blue}{\textbf{<-}}$).
* There are $\textbf{less favored}$ ways:
  * A simple equality sign ($\textcolor{blue}{\textbf{=}}$).
  * Using the $\textcolor{blue}{\textbf{assign()}}$ function.
  
## Examples 

* Clean up the global environment i.e. remove all objects from the current R environment.\newline
  $\textcolor{orange}{\texttt{Recommended!}}$

```{R, echo=TRUE, comment=''}
rm(list=ls())
ls()
```

$\newline$

* $\textbf{preferred}$ way to assign variables
```{R, echo=TRUE, comment=''}
x <- 5.0 
x
```

$\newline$

* alternative 1: mainly used to assign default function arguments
```{R, echo=TRUE, comment=''}
y = 5.0 
y

mysamplevariance <- function(x, av=0){
  
  n <- length(x)
  if(n>1){
      return(1.0/(n-1)*sum((x-av)^2))
  }
  else{
      stop("ERROR:: Dividing by zero (n==1) || (n==0) ")
  }  
}

x <- rnorm(10)
mysamplevariance(x)
mysamplevariance(x,mean(x))
var(x)
```

$\newline$

* alternative 2: even less used

```{r}
assign("z", 5.0) 
z
```

$\newline$

* functions are objects
```{R, echo=TRUE, comment=''}
f <- mean
f
val <- f(1:10)
val
```

\newpage

$\texttt{"Nothing exists except atoms and empty space; everything else is opinion". (Democritos)}$

# Atomic Data Types

## The core/atomic data types
* R has the following 6 $\textcolor{blue}{\textbf{atomic}}$ data types:

  * logical (i.e. boolean)
  * integer
  * double
  * character (i.e. string)
  * complex
  * raw (i.e. byte)

The latter 2 types (i.e. complex and especially raw) are less common.

The $\textcolor{blue}{\textbf{typeof()}}$ 
function determines the **INTERNAL** storage/type of an R object.

```{r, echo=FALSE, results='hide'}
# Clean up env.
rm(list=ls())
ls()
```

### Examples

* boolean/logical values: either $\textcolor{blue}{\textbf{TRUE}}$ or $\textcolor{blue}{\textbf{FALSE}}$

```{R, echo=TRUE, comment=''}
x1 <- TRUE
x1
typeof(x1)
```

$\newline$

* integer values ($\in \, \mathbb{Z}$): 

```{r echo=TRUE}
x2 <- 3L
x2  
typeof(x2)
```

$\newline$

* double (precision) values:

```{r echo=TRUE}
x3 <- 3.14
x3 
typeof(x3)
```

$\newline$

* character values/strings

```{r echo=TRUE}
x4 <- "Hello world"
x4
typeof(x4)
```

$\newline$

* complex values ($\in \, \mathbb{C}$):

```{r echo=TRUE}
x5 <- 2.0 + 3i 
x5  
typeof(x5)
```

\newpage

## Operations on atomic data types
* $\textbf{logical}$ operators:  $\textcolor{blue}{\textbf{==}}$, $\textcolor{blue}{\textbf{!=}}$, $\textcolor{blue}{\textbf{\&\&}}$, $\textcolor{blue}{\textbf{||}}$, $\textcolor{blue}{\textbf{!}}$
* $\textbf{numerical}$ operators: $\textcolor{blue}{\textbf{+}}$, $\textcolor{blue}{\textbf{-}}$, $\textcolor{blue}{\textbf{*}}$, $\textcolor{blue}{\textbf{/}}$, $\textcolor{blue}{\textbf{\textasciicircum}}$, $\textcolor{blue}{\textbf{**}}$ (same as the caret), but also:
  * integer division: $\textcolor{blue}{\textbf{\%/\%}}$
  * modulo operation: $\textcolor{blue}{\textbf{\%\%}}$
  * $\textcolor{orange}{\textbf{Note}}$: matrix multiplication will be performed using $\textcolor{blue}{\textbf{\%*\%}}$
* $\textbf{character/string}$ manipulation: 
  * $\textcolor{blue}{\textbf{nchar()}}$:
  * $\textcolor{blue}{\textbf{paste()}}$:
  * $\textcolor{blue}{\textbf{cat()}}$:
  * $\textcolor{blue}{\textbf{sprintf()}}$:
  * $\textcolor{blue}{\textbf{substr()}}$:
  * $\textcolor{blue}{\textbf{strsplit()}}$:
  * $\textcolor{orange}{\textbf{Note}}$: Specialized R libraries were developed to manipulate strings e.g. $\href{https://cran.r-project.org/web/packages/stringr/index.html}{stringr}$
* explicit $\textbf{cast}$/conversion: https://data-flair.training/blogs/r-string-manipulation/
  * $\textcolor{blue}{\textbf{as.\{logical, integer, double, complex, character\}()}}$
* explicit $\textbf{test}$ of the type of a variable:
  * $\textcolor{blue}{\textbf{is.\{logical, integer, double, complex, character\}()}}$
  
### Examples

* Logical operators:
```{R, echo=TRUE}
x <-3 
y <-7
(x<=3) &&(y==7)
!(y<7)
```
 
$\newline$

* Mathematical operations
```{R, echo=TRUE}
2**4
7%%4
7/4
7%/%4
```
 
$\newline$ 
 
* String operations
```{R, echo=TRUE}
s <- "Hello"
nchar(s)
news <- paste(s,"World")
news
sprintf("My new string:%20s\n", news)
city <- "Witwatersrand"
substr(city,4,8)
```
 
$\newline$ 

* Conversion and testing of types
```{R, echo=TRUE}
s <- "Hello World"
is.character(s)
```

$\newline$

```{R, echo=TRUE}
s1 <- "-500"
is.character(s1)
```

$\newline$
```{R, echo=TRUE}
s2 <- as.double(s1)
is.character(s2)
is.double(s2)
```

$\newline$
```{R, echo=TRUE}
s3 <- as.complex(s2)
s3
sqrt(s3)
```
 
\newpage

# Atomic vectors

* An $\textbf{atomic}$ vector is a data structure containing 
elements of $\textbf{only one atomic}$ data type.\newline
Therefore, an atomic vector is $\textbf{homogeneous}$.
* Atomic vectors are stored in a $\textbf{linear}$ fashion.
* R does $\textbf{NOT}$ have scalars:
    * An atomic vector of $\textbf{length 1}$ plays the role of a scalar. 
    * Vectors of $\textbf{length 0}$ also exist (and they have some use!).
* A $\textbf{list}$ is a vector not necessarily of the atomic type.\newline A list is also
known as a $\textbf{recursive/generic}$ vector ($\textit{vide infra}$).

## Creation of atomic vectors
Atomic vectors can be created in a multiple ways:

* Use of the $\textcolor{blue}{\textbf{vector()}}$ function.
* Use of the $\textcolor{blue}{\textbf{c()}}$ function (**c** stands for concatenate).
* Use of the column operator $\textcolor{blue}{\textbf{:}}$
* Use of the $\textcolor{blue}{\textbf{seq()}}$ and $\textcolor{blue}{\textbf{rep()}}$ functions.

The length of a vector can be retrieved using the $\textcolor{blue}{\textbf{length()}}$ function.


```{r, echo=FALSE, results='hide'}
rm(list=ls())
ls()
``` 

### Examples 

* use of the $\textcolor{blue}{\textbf{vector()}}$ function:
```{r echo=TRUE}
x <- vector()  # Empty vector (Default:'logical')
x
length(x)
typeof(x)
```

$\newline$

```{r}
x <- vector(mode="complex", length=4) 
x
length(x)
x
x[1] <- 4
x
```

* use of the $\textcolor{blue}{\textbf{c()}}$ function:
```{r}
x1 <- c(3, 2, 5.2, 7) 
x1
x2 <- c(8, 12, 13) 
x2
x3 <- c(x2, x1) 
x3
x4 <- c(FALSE,TRUE,FALSE) 
x4
x5 <- c("Hello", "Salt", "Lake", "City") 
x5
```

$\newline$

* use of the column operator:
```{r}
y1 <- 1:10 
y1
y2 <- 5:-5 
y2
y3 <- 2.3:10 
y3
y4 <- 2.0*7:1 
y4
y5 <- 1:7-1 
y5
```

* $\textcolor{blue}{\textbf{seq()}}$ and $\textcolor{blue}{\textbf{rep()}}$ functions
```{r}
z1 <- seq(from=1, to=15, by=3)
z1
z2 <- seq(from=-2,to=5,length=4) 
z2
```

$\newline$

```{r}
z3 <- rep(c(3,2,4), time=2)
z3
z4 <- rep(c(3,2,4), each=3)
z4
z5 <- rep(c(1,7), each=2, time=3) 
z5
length(z5)
```

## Operations on vectors: element-wise

* All operations on vectors in R happen $\textbf{element by element}$ (cfr. $\textit{NumPy}$).
* $\textcolor{blue}{\textbf{Vector Recycling}}$:

  If 2 vectors of \textbf{different} lengths are involved in an operation, the \textbf{shortest vector} 
  will be repeated until all elements of the longest vector are matched. \newline
  A message will be sent to the stdout.

### Examples  
```{r}
x <- -3:3
x
y <- 1:7
y
xy <- x*y
xy
xpy <- x^y
xpy
```

$\newline$

```{r}
x <- 0:10
y <- 1:2
length(x)
length(y)
x
y
x+y
```

## Retrieving elements of vectors

* Indexing: starts at $\textbf{1}$ ($\textbf{not 0}$ like C/C++, Python, Java, ....)
  see also: $\newline$
  \href{https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF}{Edsger Dijkstra: Why numbering should start at zero}
* Use of vector with indices to extract values.
* Advanced features:
  * use of boolean values to extract values.
  * the membership operator: $\textcolor{blue}{\textbf{\%in\%}}$.
  * the deselect/omit operator: $\textcolor{blue}{\textbf{-}}$ 
  * $\textcolor{blue}{\textbf{which()}}$: returns the indices for which the condition is true.
  * $\textcolor{blue}{\textbf{any()}}$/$\textcolor{blue}{\textbf{all()}}$ functions.
    * $\textcolor{blue}{\textbf{any()}}$ : $\textcolor{blue}{\textbf{TRUE}}$ if at least $1$ value is true
    * $\textcolor{blue}{\textbf{all()}}$ : $\textcolor{blue}{\textbf{TRUE}}$ if all values are true

### Examples

* Use of a simple index:
```{r}
x <- seq(2,100,by=15)
x[4]
x[1]
```

$\newline$

* Select several indices at once using vectors:
```{r}
x
x[3:5]
x[c(1,3,5,7)]
x[seq(1,7,by=2)]
```

$\newline$

* Extraction via booleans (i.e. retain only those values that are equal to $\textcolor{blue}{\textbf{TRUE}}$):
```{r}
x
x>45
x[x>45]
```

$\newline$

* Use of the $\textcolor{blue}{\textbf{\%in\%}}$ operator:
```{r}
x
10 %in% x
62 %in% x
c(32,33,43) %in% x
!(c(32,33,43) %in% x)
```

$\newline$

* Negate/filter out the elements with $\textbf{negative}$ indices:
```{r}
x
x[-c(2,4,6)]
z <- x[-1] - x[-length(x)]
z
```

$\newline$

* The $\textcolor{blue}{\textbf{which()}}$ function returns 
$\textbf{only those indices}$ of which the condition/expression is \textbf{true}.

```{r}
# Sample 10 numbers from N(0,1)
vecnum <- rnorm(n=10)
vecnum
which(vecnum>1.0)
```

$\newline$

* Use of the $\textcolor{blue}{\textbf{any()}}$/$\textcolor{blue}{\textbf{all()}}$ functions.
  
```{r}
y <- seq(0,100,by=10)
x
y
any(x<y)
all(x[6:7]>y[2:3])
```


## Hash tables 
 
A $\textbf{hash table}$ is a data structure which implements an associative array or dictionary.
It is an abstract data which maps data to keys.

* There are several ways to create one:
  * Map names to an existing vector
  * Add names when creating the vector
* To remove the map, map the names to NULL


### Examples

* Creation of 2 independent vectors
```{R echo=TRUE}
capitals <- c("Albany", "Providence", "Hartford", "Boston", "Montpelier", "Concord", "Augusta")
states <- c("NY", "RI", "CT", "MA", "VT", "NH", "ME")
capitals
states
capitals[3]
```
$\newline$

* Create the hashtable/dictionary
```{R echo=TRUE}
# Method 1
names(capitals) <- states
capitals
capitals["MA"]
names(capitals)
```

$\newline$

```{R echo=TRUE}
# Method 2
phonecode <- c("801"="SLC", "206"="Seattle", "307"="Wyoming")
phonecode
phonecode["801"]
```

$\newline$

* Dissociate the 2 vectors
```{R echo=TRUE}
names(capitals) <- NULL
capitals
```


## NA (Not Available values)

* $\textcolor{blue}{\textbf{NA}}$: stands for 'Not Available'/Missing values
* has length of $1$.
* $\textcolor{blue}{\textbf{is.na()}}$: test all elements of a vector for NA values.
* some functions e.g. $\textcolor{blue}{\textbf{mean()}}$ return NA when an instance of NA is present.

### Examples

* Check of the NA availability
```{R, echo=TRUE}
x <- c(NA, 1, 2, NA)
is.na(x)
```

$\newline$

* Functions on a vector containing NA
```{R, echo=TRUE}
mean(x)
mean(x, na.rm=TRUE)
```

## Alia 

$\textcolor{red}{\textbf{Still to be developed!}}\newline$

* boolean: Vector operators vs. unique value
* && vs. &.
* || vs. |.
* xor()

\newpage

$\texttt{"It is my experience that proofs involving matrices can be}\newline
 \texttt{shortened by 50\% if one throws the matrices out" (Emil Artin)}$


# Matrices & Arrays

Matrices and arrays are $\textbf{homogeneous atomic vectors}$ with$\newline$
an $\textbf{extra}$ attribute: dimension

By default, the elements are stored in a $\textbf{column-major}$ fashion. (cfr. $\textbf{Fortran}$).$\newline$
However, we can store the elements in $\textbf{row-major}$ order (cfr. $\textbf{C}$) as well.

## Creation of matrices

Matrices can be created in different ways:

* use of the $\textcolor{blue}{\textbf{matrix()}}$ function
* use of $\textcolor{blue}{\textbf{rbind()}}$/$\textcolor{blue}{\textbf{cbind()}}$
* set the $\textcolor{blue}{\textbf{attributes()}}$ of a vector
* special functions like e.g. $\textcolor{blue}{\textbf{diag()}}$

### Examples

* use of the $\textcolor{blue}{\textbf{matrix()}}$ function:

The $\textcolor{blue}{\textbf{matrix()}}$ function creates a matrix based on a vector.$\newline$
By default, the elements are stored in a $\textbf{column-major}$ fashion. 

The use of the flag $\texttt{byrow=TRUE}$ will store the data in a $\textbf{row-major}$ fashion.

```{R, echo=TRUE}
A <- matrix(data=1:10, nrow=2)   # Column-major (like Fortran)
A

B <- matrix(data=c(2,3,893,0.17), nrow=2, ncol=2)
B
```


$\newline$
```{R, echo=TRUE}
C <- matrix(data=1:10, nrow=2, byrow=TRUE)   # Row-major (like C, C++)
C
```

$\newline$

* use of the $\textcolor{blue}{\textbf{rbind()}}$/$\textcolor{blue}{\textbf{cbind()}}$ functions:
  
  - $\textcolor{blue}{\textbf{rbind()}}$: Bind several vectors (as rows) into a matrix.
  - $\textcolor{blue}{\textbf{cbind()}}$: Bind several vectors (as columns) into a matrix.
  
```{R,echo=TRUE}
A <- rbind(1:10,11:20)  
A
typeof(A)
class(A)
```

$\newline$

```{R, echo=TRUE}
B <- cbind(1:5,6:10,11:15)
B
class(B)
```

* modifying the $\textcolor{blue}{\textbf{dim}}$ attribute.

The $\textbf{fundamental}$ difference between an $\texttt{R}$ vector and matrix is
the presence (in the case of matrices) of a non $\texttt{NULL}$ 
$\textcolor{blue}{\textbf{dim}}$ attribute. 

We change easily convert a vector into a matrix by setting the dimensions of the vector:

\begin{itemize}
\item through the $\textcolor{blue}{\textbf{dim()}}$ function.
\item through the $\textcolor{blue}{\textbf{attr()}}$ function.
\end{itemize}

The inverse can be done as well by setting the $\textcolor{blue}{\textbf{dim}}$ attribute 
of matrix to $\texttt{NULL}$.

### Examples

```{R, echo=TRUE}
A <- 1:10 
typeof(A)
class(A)
dim(A)
```

$\newline$

```{R, echo=TRUE}
# Matrix
B <- matrix(1:10,nrow=2,ncol=5,byrow=TRUE) 
typeof(B)
class(B)
dim(B)
```  

$\newline$
```{R, echo=TRUE}
# Vector
A <- 1:10
A
dim(A) 
typeof(A)
class(A)
```

$\newline \newline$

```{R, echo=TRUE}
# OPTION I: Using the dim function transform a vector into a matrix
dim(A) <- c(2,5)
A
dim(A)
typeof(A)
class(A)
```

$\newline$

```{R, echo=TRUE}
# Converting the matrix back to a vector
dim(A) <- NULL
dim(A)
typeof(A)
class(A)
```

$\newline \newline$

```{R, echo=TRUE}
# Option II: More general way 
# Convert vector into a matrix
A <- 1:8
A
class(A)

attr(A,'dim') <- c(2,4)
A
class(A)
```

$\newline$

```{R, echo=TRUE}
# Convert matrix into a vector.
attr(A, 'dim') <- NULL
A
class(A)
```




## Operations on matrices

* Operations like $\textcolor{blue}{\textbf{*,/, +}}$ happpen element-wise.
* There are also more specialized functions:
  * the mean over rows and columns ($\textcolor{blue}{\textbf{rowMeans()}}$, $\textcolor{blue}{\textbf{colMeans()}})$
  * linear algebra functions ($\textcolor{blue}{\textbf{\%*\%}}$, $\textcolor{blue}{\textbf{t()}}$, ...)
    
### Examples

* Operations (by $\textbf{default: element-by-element}$):

```{R, echo=TRUE}
A <- matrix(1:10, nrow=2)
B <- matrix( seq(10, 100, by=10), nrow=2)
A
B
```

$\newline$

```{R, echo=TRUE}
A*B
```

$\newline$
```{R, echo=TRUE}
C <- matrix(rep(2,10), nrow=2)
C**A
```

* Calculate $\textbf{row and column means}$ :

```{R, echo=TRUE}
# Means of rows and columns
A
rowMeans(A)
colMeans(A)
```

* $\textbf{Matrix multiplication}$ ($\textcolor{blue}{\textbf{\%*\%}}$) :

```{R, echo=TRUE}
A <- matrix(1:6, nrow=2)
A
B <- matrix(seq(10,120,by=10), nrow=3)
B
C <- A%*%B
C
dim(C)
```

* $\textbf{Linear algebra}$ routines

Some of the more common ones in R:
\begin{itemize}
 \item $\textcolor{blue}{\textbf{solve()}}$ : $\textbf{invert}$ a square matrix
 \item $\textcolor{blue}{\textbf{diag()}}$
    \begin{itemize}
       \item $\textbf{extracts}$ the diagonal of a matrix when a matrix is provided.
       \item $\textbf{creates}$ a diagonal matrix when a vector is provided.
    \end{itemize}
 \item $\textcolor{blue}{\textbf{eigen()}}$ : calculates the $\textbf{eigenvalues}$ and $\textbf{eigenvectors}$ of a matrix
 \item $\textcolor{blue}{\textbf{det()}}$ : calculates the $\textbf{determinant}$ of a matrix.
 \item $\textcolor{blue}{\textbf{t()}}$: calculates the $\textbf{transpose}$$\footnote{Can also be used for dataframes (see later)}$ of a matrix.
\end{itemize}
  
```{R, echo=TRUE}
# Invert matrix A
A <- matrix(c(1, 3, 2, 4), ncol = 2, byrow = T)
Ainv <- solve(A)
Ainv %*% A
```

$\newline$

```{R, echo=TRUE}
# Create a diagonal matrix
C <- diag(c(1,4,7))
C

# Extract the diagonal elements
D <- matrix(1:8,nrow=4)
D
diag(D)
```
$\newline$

```{R, echo=TRUE}
# Calculate eigenvalues and eigenvectors of A
r <- eigen(A)
r
# Eigenvalues
r$values
# Matrix with eigenvectors
r$vectors
# Diagonal Matrix (Similarity Transformation)
solve(r$vectors) %*% A %*% r$vectors
```

Note that under the hood $\texttt{R}$ calls [$\texttt{BLAS}$](https://netlib.org/blas/) and [$\texttt{LAPACK}$](https://netlib.org/lapack/).

```{R, echo=TRUE}
# Find the version used of BLAS and LAPACK
La_library()
extSoftVersion()["BLAS"]
```

## Hash Tables

\newpage

# Other types

* Attributes
* Special types:
  * Factors
  * Date
  * Time
* NA, NaN, NULL

\newpage

## Other topics on Data structures {-}
* List
* Dataframe & Tibble
* IO (read.csv, read.file)

* Names
* Subsetting, [[]] vs. []


## Conditionals & Loops {-}
* if, else, else if switch and elseif
* for
* while
* repeat
* return() 

## Environments {-}
* search(), attach, detach
* library

## Functions {-}
* lexical scoping
* simple functions
* args(), formals()
* default arg, ... 
* lazy evaluation
* closure
* anonymous functions
* make your own operators
* loop functions: {l,s,m}apply, split

## Capita selecta {-}
* profiling, debugging
